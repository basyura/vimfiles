""""""""""""""""""""""""""""""""""
"         core settings          "
""""""""""""""""""""""""""""""""""
if expand("%") != ".git/COMMIT_EDITMSG"
	filetype plugin indent on
	syntax enable
	colorscheme desert
	set runtimepath+=~/.vim
	set runtimepath+=~/.vim/plugins/*
	set runtimepath+=~/.vim/gitplugins/*
  let g:vimball_home = "~/.vim"

  call altercmd#load()
endif

if &termencoding == ''
  let &termencoding="utf-8"
"  let &termencoding="cp932"
endif

let mapleader = "m"

""""""""""""""""""""""""""""""""""
"        init variables          "
""""""""""""""""""""""""""""""""""

if !exists('g:use_fuzzy_finder')
  let g:use_fuzzy_finder = 0
endif

""""""""""""""""""""""""""""""""""
"           settings             "
""""""""""""""""""""""""""""""""""


if filereadable($HOME . '/.vimrc_secret')
  source ~/.vimrc_secret
endif

if has('win32')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/windows/proc.dll'
elseif has('win32unix')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/cygwin/proc.dll'
elseif has('mac')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/mac/proc.so'
endif

set ambiwidth=double
set nu
set autoindent
set iminsert=0
set titlestring=%<%f\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}
set laststatus=0
set linespace=2
set antialias
"set nobackup
set backupdir=~/.vim/backup
set directory=~/.vim/swp
"オートインデント時にタブが2つ入ることを防ぐ
set ts=4 sw=4 sts=0
set scrolloff=5
set wrap
set hlsearch
set smartindent
set timeout timeoutlen=300 ttimeoutlen=100
set shellslash
"set cmdheight=1

" ubuntu だと画面がちらつく。mac だと音が出ちゃう。
if has('mac')
  set vb t_vb=
endif

set tabstop=2
set shiftwidth=2
set expandtab

""""""""""""""""""""""""""""""""""
"         auto command           "
""""""""""""""""""""""""""""""""""
augroup MyGroup
  autocmd! MyGroup
  au BufEnter * set bh=hide
  au BufNewFile,BufRead *.scala setf scala
  "set autochdir
  au BufEnter * execute ":lcd " . substitute(expand("%:p:h")," ","\\\\ ","g")
  " for ruby
  autocmd FileType ruby  :setlocal tabstop=2
  autocmd FileType ruby  :setlocal shiftwidth=2
  autocmd FileType ruby  :setlocal expandtab
  " for eruby
  autocmd FileType eruby :setlocal tabstop=2
  autocmd FileType eruby :setlocal shiftwidth=2
  autocmd FileType eruby :setlocal expandtab
  " for scala
  autocmd FileType scala :setlocal tabstop=2
  autocmd FileType scala :setlocal shiftwidth=2
  autocmd FileType scala :setlocal expandtab
  " for vim
  autocmd FileType scala :setlocal tabstop=4
  autocmd FileType scala :setlocal shiftwidth=4
  autocmd FileType scala :setlocal noexpandtab
  " for java
  autocmd FileType java :setlocal tabstop=4
  autocmd FileType java :setlocal shiftwidth=4
  autocmd FileType java :setlocal noexpandtab
  " for javascript
  autocmd FileType javascript :setlocal tabstop=2
  autocmd FileType javascript :setlocal shiftwidth=2
  autocmd FileType javascript :setlocal expandtab

  autocmd FileType netrw setlocal buftype=nofile bufhidden=delete

  autocmd FileType fuf NeoComplCacheLock
  autocmd FileType vimwiki NeoComplCacheLock

  autocmd FileType vimshell call s:vimshell_my_settings()
  autocmd FileType unite    call s:unite_my_settings()
  autocmd FileType fuf      call s:fuf_my_settings()
  autocmd FileType scratch  call s:scratch_my_settings()
  autocmd FileType twitvim  call s:twitvim_my_settings()
  autocmd FileType twitvim_say  call s:twitvim_say_my_settings()

  autocmd CmdwinEnter * call s:init_cmdwin()

  autocmd FileType lingr-rooms    :setlocal nonu
  autocmd FileType lingr-rooms    :setlocal nowrap
  autocmd FileType lingr-members  :setlocal nonu
  autocmd FileType lingr-members  :setlocal nowrap
  autocmd FileType lingr-messages :setlocal nonu
  autocmd FileType lingr-messages call s:lingr_messages_setting()
  autocmd FileType lingr-say      call s:lingr_say_setting()
augroup END


""""""""""""""""""""""""""""""""""
"            colors              "
""""""""""""""""""""""""""""""""""
hi Cursor	  guifg=bg	guibg=orange
" lingr
hi link lingrMessagesSpeaker Statement
hi link lingrRoomsActive     Statement
" wimwiki
hi link VimwikiPre Normal
""""""""""""""""""""""""""""""""""
"             map                "
""""""""""""""""""""""""""""""""""
map <silent> <S-u> :redo<CR>
map bn    :bnext<CR>
"ウインドウのフォーカス移動
map  wh <C-w>h
map  wl <C-w>l
map  wj <C-w>j
map  wk <C-w>k
map gl :macaction selectNextWindow:<CR>
map gh :macaction selectPreviousWindow:<CR>

nnoremap <Space>.   :<C-u>edit   $MYVIMRC<Enter>
nnoremap <Space>s.  :<C-u>source $MYVIMRC<Enter>
nnoremap <Space>g.  :<C-u>edit   $MYGVIMRC<Enter>
noremap  <Space>gs. :<C-u>source $MYGVIMRC<Enter>
noremap  <Space>v.  :<C-u>edit   ~/.vimshrc<Enter>
inoremap <C-d> <Del>
cmap <C-d> <Del>

inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

"コマンドモードで Ctl + v で貼り付ける
cmap <C-v> <C-R>+
"挿入モードで Ctl + v で貼り付ける
imap <C-v> <C-R>+
"全て選択
map  <C-a><C-a> ggvG$
"貼り付け
map  <C-v> "+gP
" gvim で q → bd をしてる用
map <C-q><C-q><C-q> ZQ

cmap <C-e> <End>
cmap <C-a> <HOME>
cmap <C-f> <Right>
cmap <C-b> <Left>
imap <C-e> <End>
imap <C-a> <HOME>
imap <C-f> <Right>
imap <C-b> <Left>

nnoremap <C-e> <End>
nnoremap <C-a> <HOME>
nnoremap <C-f> <Right>
nnoremap <C-b> <Left>
"map <C-e> :Tlist<CR>
vmap <C-b> :Batch<CR>

nnoremap <M-k> <C-y>
nnoremap <M-j> <C-e>
"nnoremap <C-s> :Scratch<CR>
nnoremap <Leader>s :Scratch<CR>
"nnoremap <Leader>s :sp ~/.[scratch]<CR>
nnoremap <Leader>v :VimShell<CR>
nnoremap <Leader>w :w<CR>
nnoremap <silent> <Leader>o :on<CR>
nnoremap <Leader><Leader> <C-]>
nnoremap <Space>d :<C-u>pwd<CR>
nnoremap <C-l> :FufBufferTag<CR>
nnoremap <C-t> :FufTag<CR>
nnoremap <C-x><C-x> :tabnew<CR>
nnoremap <C-x><C-l> :tabnext<CR>
nnoremap <C-x><C-h> :tabprevious<CR>
" ターミナルだとなぜか起動時にインサートモードになるので
if has('gui_running')
  nnoremap <silent> <ESC> :noh<CR>
endif

inoremap <silent><C-o> <ESC>o
inoremap <C-j> <ESC>
inoremap jj <ESC>
noremap <C-j> <ESC>
inoremap kk <ESC><S-o>

vnoremap <C-e> <End><Left>

""""""""""""""""""""""""""""""""""
"        neo complcache          "
""""""""""""""""""""""""""""""""""
" 起動時に有効
let g:neocomplcache_enable_at_startup = 1

" snippet ファイルの保存先
let g:neocomplcache_snippets_dir='~/.vim/snippets'
" dictionary
let g:neocomplcache_dictionary_filetype_lists = {
    \ 'objc'       : $HOME . '/.vim/dict/objc.dict',
    \ 'javascript' : $HOME . '/.vim/dict/js.dict',
    \ 'ruby'       : $HOME . '/.vim/dict/ruby.dict',
    \ 'eruby'      : $HOME . '/.vim/dict/ruby.dict',
    \ 'java'       : $HOME . '/.vim/dict/java.dict',
    \ 'vimshell'   : $HOME . '/.vimshell_hist',
    \ 'twitvim_say': $HOME . '/.vim/dict/twitvim_say.dict',
    \ 'default'    : $HOME . '/.vim/dict/default.dict'
\ }

" 日本語をキャッシュしない
if !exists('g:neocomplcache_keyword_patterns')
	let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
" 補完候補の数
"let g:neocomplcache_max_list = 5
" 補完しなくなる文字数
let g:neocomplcache_enable_auto_select = 1
" 補完しないパターン
let g:neocomplcache_disable_caching_buffer_name_pattern = '.*fuf.*\|*.log\|unite'
" 自動補完しないパターン
let g:neocomplcache_lock_buffer_name_pattern = '*.log\|.*fuf.*\|unite\|.*quickrun.*'
" 自動選択しないパターン
let g:neocomplcache_disable_auto_select_buffer_name_pattern = 'vimshell\|unite'
" キャッシュ中に、メッセージをCommand-lineに表示しない
let g:neocomplcache_enable_caching_message = 0
" キー入力時にキーワード補完を行う入力数を制御する。
let g:neocomplcache_auto_completion_start_length = 3
"入力に大文字が含まれている場合は、大文字・小文字を無視しない 
"let g:neocomplcache_enable_smart_case = 0
" セパレータ補完
"let g:neocomplcache_enable_auto_delimiter = 1
" 辞書読み込み
noremap  <Space>d. :<C-u>NeoComplCacheCachingDictionary<Enter>
" <TAB> completion.
inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
" C-jでオムニ補完
"inoremap <expr> <C-j> &filetype == 'vim' ? "\<C-x>\<C-v>\<C-p>" : "\<C-x>\<C-o>\<C-p>"
" C-kを押すと行末まで削除
inoremap <C-k> <C-o>D
" C-nでneocomplcache補完
inoremap <expr><C-n>  pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>"
" C-pでkeyword補完
"inoremap <expr><C-p> pumvisible() ? "\<C-p>" : "\<C-p>\<C-n>"
" 補完候補が出ていたら確定、なければ改行
inoremap <expr><CR>  pumvisible() ? neocomplcache#close_popup() : "<CR>"
"inoremap <expr><C-e> pumvisible() ? neocomplcache#close_popup() : "<End>"
" 補完をキャンセル
inoremap <expr><C-c>  neocomplcache#cancel_popup()
" 補完をアンドゥ
inoremap <expr><C-u>  neocomplcache#undo_completion()

inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
"map <silent> <ESC> <ESC>:set iminsert=0<CR>
" snippet 補完
imap <silent> <C-l> <Plug>(neocomplcache_snippets_expand)
smap <silent> <C-l> <Plug>(neocomplcache_snippets_expand)
command! -nargs=* Nes NeoComplCacheEditSnippets <args>
command! -nargs=* Nel NeoComplCacheLock <args>


""""""""""""""""""""""""""""""""""
"            vimshell            "
""""""""""""""""""""""""""""""""""

let g:vimshell_prompt = '$ '
let g:vimshell_edit_no_split = 1
"let g:vimshell_user_prompt = 'getcwd()'
let g:vimshell_interactive_cygwin_path = 'D:/develop/dev/cygwin/bin'
let g:vimshell_interactive_cygwin_home = 'D:/develop/dev/cygwin/home/Administrator'
let g:vimshell_split_command = 'split'
" ディレクトリの補完時に/を補います
let g:vimshell_enable_auto_slash = 1
"let g:vimshell_split_command = "vsplit"
if !exists('g:vimshell_interactive_cygwin_commands')
  let g:vimshell_interactive_cygwin_commands = {}
endif
let g:vimshell_interactive_cygwin_commands['git'] = {
  \ 'name' : 'git',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
let g:vimshell_interactive_cygwin_commands['termtter'] = {
  \ 'name' : 'termtter',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
let g:vimshell_interactive_cygwin_commands['irb'] = {
  \ 'name' : 'irb',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
let g:vimshell_interactive_cygwin_commands['rake'] = {
  \ 'name' : 'rake',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}

function! s:vimshell_my_settings()
" imap <buffer><expr> <CR> (pumvisible() ? "<C-y>" : "<Plug>(vimshell_enter)")
  "imap <buffer><expr> <CR> (pumvisible() ? "<C-y><Tab>" : "<Plug>(vimshell_enter)")
  inoremap <buffer> <C-x> <ESC><C-w>h:on<CR>
  nnoremap <buffer> <CR> Go$ 
  imap <buffer> <C-x>     <ESC><C-w>h:on<CR>
  inoremap <C-v> <C-R>+
  inoremap <buffer><expr><C-h> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
  imap <buffer> <C-o> <Plug>(vimshell_enter)
  inoremap <buffer> <C-l> <C-y>
  imap <buffer> <C-s> <Plug>(vimshell_history_complete_whole)
  nunmap <buffer> <C-d>

  if g:use_fuzzy_finder == 1
    inoremap <buffer> <silent> <C-n>  <ESC>:<C-u>FufBuffer<CR>
    inoremap <buffer> <silent> <C-r>  <ESC>:<C-u>FufMruFile<CR>
    nnoremap <buffer><silent> <C-n>  :<C-u>FufBuffer<CR>
  else
    inoremap <buffer> <silent> <C-n>  <ESC>:<C-u>Unite buffer_tab <CR>
    inoremap <buffer> <silent> <C-r>  <ESC>:<C-u>Unite file_mru <CR>
    nnoremap <buffer><silent> <C-n>  :<C-u>Unite buffer_tab <CR>
  endif

  NeoComplCacheAutoCompletionLength 3
endfunction


""""""""""""""""""""""""""""""""""
"            vimfiler            "
""""""""""""""""""""""""""""""""""

let g:vimfiler_as_default_explorer = 1

""""""""""""""""""""""""""""""""""
"      unite or fuzzyfinder      "
""""""""""""""""""""""""""""""""""
let mru_ignore = '.*\/$\|.*Application\ Data.*\|.*デスクトップ.*'
"let g:fuf_keyOpen = ":"
"let g:fuf_maxMenuWidth = 90
let g:fuf_modesDisable     = ['mrucmd']
let g:fuf_mrufile_exclude  = ''
let g:fuf_timeFormat       = ''
let g:fuf_keyOpenVsplit    = '<C-v>'
let g:fuf_keyOpenSplit     = '<C-k>'
let g:fuf_enumeratingLimit = 20
let g:fuf_mrufile_exclude = mru_ignore

if g:use_fuzzy_finder == 1
  " 読み込んだことにしたいけどエラー出るのでコメントアウト
  "let g:loaded_unite = 1

  "nnoremap <silent> <Leader>d :<C-u>CD<CR>:FufFile<CR>
  nnoremap <C-r> :FufMruFile<CR>
  nnoremap <C-n> :FufBuffer<CR>
  nnoremap <Leader>d :<C-u>FufFile<CR>
  nnoremap <Leader>f :FufFile **/
  nnoremap <Leader>b :FufBookmarkFile<CR>
else
  " 読み込んだことにする
  let g:fuf_modesDisable = ['mrucmd','mrufile','file','coveragefile']

  nnoremap <C-r>  :<C-u>Unite file_mru<CR>
  nnoremap <C-n>  :<C-u>Unite buffer_tab <CR>
  nnoremap <Leader>d :<C-u>Unite file<CR>
  nnoremap <Leader>f  :<C-u>Unite file_rec -input=
  nnoremap <Leader>b :<C-u>Unite bookmark<CR>
end

nnoremap <silent> <Leader>u  :<C-u>Unite buffer_tab file file_mru bookmark<CR>

"let g:unite_update_time = 200
let g:unite_source_file_mru_time_format = ''
let g:unite_enable_start_insert = 1
let g:unite_source_file_mru_ignore_pattern = mru_ignore
let g:unite_source_file_mru_limit = 1000
call unite#set_substitute_pattern('', '[[:alnum:]]', '*\0', 100)



function! s:unite_my_settings()
  " Overwrite settings.
  imap <buffer> jj <Plug>(unite_insert_leave)
  "imap <buffer> jj <Plug>(unite_exit)
  imap <buffer> <C-j> <Plug>(unite_exit)
  imap <buffer> <ESC> <Plug>(unite_exit)
	imap <buffer> <C-o> <Plug>(unite_insert_leave):<C-u>call unite#mappings#do_action('above')<CR>
  nmap <buffer> d     <Plug>(unite_do_delete_action)
  nmap <buffer> <C-n> <Plug>(unite_loop_cursor_down)
  nmap <buffer> <C-p> <Plug>(unite_loop_cursor_up)
  nmap <buffer> <C-j> <Plug>(unite_exit)
  "startinsert
endfunction
function! s:fuf_my_settings()
  inoremap <buffer> <C-j> <ESC>
endfunction

""""""""""""""""""""""""""""""""""
"             misc               "
""""""""""""""""""""""""""""""""""
" hatena.vim
let g:hatena_user = 'basyura'
let g:scratchBackupFile=$HOME . "/.scratch.txt"
"let g:hatena_edit_new_tab = 1
" vimwiki

if !exists('g:vimwiki_list')
  if has('mac')
    let g:vimwiki_list = [{'path':'~/dropbox/vimwiki/text/', 'path_html':'~/dropbox/vimwiki/html/'}]
  else
    let g:vimwiki_list = [{'path': "Z:/text", 'path_html/': "Z:/html/"}]
  endif
end
" taglist
let g:Tlist_GainFocus_On_ToggleOpen = 1
let g:Tlist_Show_One_File = 1
let Tlist_Close_On_Select = 1
" ubuntu の時だけ
if !has('mac') && !has('win32') && !has('win32unix')
	inoremap <silent> <esc> <esc>:call ForceImeOff()<cr>
	inoremap <silent> <C-[> <esc>:call ForceImeOff()<cr>
	inoremap <silent> <C-c> <esc>:call ForceImeOff()<cr>
	function! ForceImeOff()
		let imeoff = system('xvkbd -text "\[Control]\[Shift]\[space]" > /dev/null 2>&1')
	endfunction
endif
	
command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>') 
function! s:ChangeCurrentDir(directory, bang)
    if a:directory == ''
        lcd %:p:h
    else
        execute 'lcd' . a:directory
    endif

    if a:bang == ''
        pwd
    endif
endfunction

" for rails.vim
nnoremap <silent> <Leader>r :<C-u>R<CR>


" Change current directory.
nnoremap <silent> <Space>cd :<C-u>CD<CR>

" twitvim
nnoremap <Space>po   :<C-u>WPosttoTwitter<Enter>
nnoremap s           :<C-u>WPosttoTwitter<Enter>
nnoremap <Space>fr   :<C-u>FriendsTwitter<Enter>
nnoremap <Space>re   :<C-u>RepliesTwitter<Enter>
nnoremap <Space>tt   :<C-u>ListTwitter tottoruby<Enter>
nnoremap <Space>nn   :<C-u>NextTwitter<Enter>
nnoremap <Space>pp   :<C-u>BackTwitter<Enter>
"nnoremap <Leader>u   yw:UserTwitter <C-R>+<CR>

if has('mac')
  let g:twitvim_browser_cmd = "open -a firefox "
else
  let g:twitvim_browser_cmd = "D:/Program\ Files/Mozilla\ Firefox/firefox.exe"
endif

"let twitvim_enable_python = 1



silent! nmap <Leader>q :QuickRun<CR>
let g:quickrun_config = {
      \ '*' : {'into' : 1},
      \}



nnoremap <Space>full :call FullScreen()<Enter>
function! FullScreen()
  set columns=195
  set lines=43
endfunction


" カーソル位置の highlight グループを取得する．
command! -nargs=0 GetHighlightingGroup echo 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '> trans<' . synIDattr(synID(line('.'),col('.'),0),'name') . '> lo<' . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'

" Load settings for each location.
augroup vimrc-local
  autocmd!
  "autocmd BufNewFile,BufReadPost,BufWinEnter * call s:vimrc_local(expand('<afile>:p:h'))
  autocmd BufNewFile,BufReadPost * call s:vimrc_local(expand('<afile>:p:h'))
augroup END

command! FindTags call s:vimrc_local(expand('<afile>:p:h'))
function! s:vimrc_local(loc)
"  let files = findfile('.vimrc.local', escape(a:loc, ' ') . ';', -1)
"  for i in reverse(filter(files, 'filereadable(v:val)'))
"    source `=i`
"  endfor
  let &l:tags=findfile('.tags' , '.;')
"  let &tags=findfile('.tags' , '.;')
endfunction



"Command-line window

set cmdwinheight=10
"nnoremap <sid>(command-line-enter) q:
"xnoremap <sid>(command-line-enter) q:
"nnoremap <sid>(command-line-norange) q:<C-u>
"nmap :  <sid>(command-line-enter)
"xmap :  <sid>(command-line-enter)
"autocmd CmdwinEnter * :NeoComplCacheLock
function! s:init_cmdwin()
  nnoremap <buffer> q <C-c><CR>
  nnoremap <buffer> <C-j> <C-c><CR>
"  inoremap <buffer> q bw
"  inoremap <buffer> wq WQ
"
"  "cnoreabbrev q   'bd'
"  "inoreabbrev q   'bd'
"  "inoreabbrev q!  'bd!'
"  "inoreabbrev wq  'WQ'
"
  nnoremap <buffer> <Esc> :<C-u><C-c><C-h>
"  inoremap <buffer> <C-c> :<ESC>
  inoremap <buffer> <ESC> :<C-u><C-c><C-h>
  nnoremap <buffer> <TAB> :<C-u>quit<CR>
  inoremap <buffer><expr><CR>  pumvisible() ? "\<C-y>" : "\<CR>"
"  "inoremap <buffer><expr><C-h> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
"  "inoremap <buffer><expr><BS>  pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
"
"  " Completion.
"  "inoremap <buffer><expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
  inoremap <buffer><expr><TAB>  "\<C-n>"
"  " カーソル移動
"  inoremap <C-k> <Up>
"  inoremap <C-j> <Down>
"
"  startinsert!
endfunction
""autocmd CmdwinLeave * call s:leave_cmdwin()
""function! s:leave_cmdwin()
""  let g:neocomplcache_auto_completion_start_length = 2
""endfunction


function! Scouter(file, ...) 
  let pat = '^\s*$\|^\s*"'
  let lines = readfile(a:file)
  if !a:0 || !a:1
    let lines = split(substitute(join(lines, "\n"), '\n\s*\\', '', 'g'), "\n")
  endif
  return len(filter(lines,'v:val !~ pat'))
endfunction
command! -bar -bang -nargs=? -complete=file Scouter
\        echo Scouter(empty(<q-args>) ? $MYVIMRC : expand(<q-args>), <bang>0)
command! -bar -bang -nargs=? -complete=file GScouter
\        echo Scouter(empty(<q-args>) ? $MYGVIMRC : expand(<q-args>), <bang>0)

if has('mac')
  let g:restart_vim_progname = "MacVim"
end


command! MoveLeft call s:MoveLeft()
function! s:MoveLeft()
  winpos 0 0
  set lines=43
endfunction
function! s:scratch_my_settings()
  AlterCommand <buffer> q :Scratch<CR>
endfunction
" for twitvim
function! s:twitvim_my_settings()
  nnoremap <buffer> <Leader>u   yw:UserTwitter <C-R>+<CR>
  nnoremap <buffer> <C-j>   :bw<CR>
endfunction
" for twitvim say
function! s:twitvim_say_my_settings()
  NeoComplCacheAutoCompletionLength 2
  AlterCommand <buffer> q bw!<CR>
  nnoremap <buffer> <silent> <C-j> :bw!<CR>
endfunction
"
function! s:lingr_messages_setting()
  nmap <buffer> <silent> <Space>po <Plug>(lingr-messages-show-say-buffer)
endfunction
function! s:lingr_say_setting()
  nmap <buffer> <silent> <C-j> <Plug>(lingr-say-close)
endfunction

"color for cygwin

if has('win32unix')
  hi Pmenu     ctermfg=white   ctermbg=darkblue cterm=none
  hi PmenuSel  ctermfg=232   ctermbg=magenta
endif

"set cmdheight=5

" vim: foldmethod=marker
