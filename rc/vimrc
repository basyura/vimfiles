"core settings{{{
""""""""""""""""""""""""""""""""""
"         core settings          "
""""""""""""""""""""""""""""""""""

if expand("%") == ".git/COMMIT_EDITMSG"
  finish
endif


filetype plugin indent on
syntax on
colorscheme desert

" メッセージ抑止
let $CYGWIN = 'nodosfilewarning'

set runtimepath^=~/.vim/gitplugins/*
set runtimepath+=~/.vim/plugins/*
set runtimepath+=~/.vim
set runtimepath+=~/.vim/after

set completeopt-=preview

helptags ~/.vim/gitplugins/vimdoc-ja/doc

call altercmd#load()

if &termencoding == ''
  let &termencoding="utf-8"
endif

let mapleader = "m"
"}}}

" settings {{{
""""""""""""""""""""""""""""""""""
"           settings             "
""""""""""""""""""""""""""""""""""

" singleton.vim
if has('clientserver') && !has('mac')
  call singleton#enable()
  let g:singleton#opener = "drop"
endif

" for unite
function! Unite_substitute(profile, pat, subst, ...)
  let priority = get(a:000, 0, 0)
  call unite#custom#profile(a:profile, 'substitute_patterns', {
        \   'pattern': a:pat,
        \   'subst': a:subst,
        \   'priority': priority,
        \ })
endfunction

if filereadable($HOME . '/.vimrc_local')
  source ~/.vimrc_local
endif

if has('win64')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/vimproc_win64.dll'
elseif has('win32')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/proc_win.dll'
elseif has('win32unix')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/proc_cygwin.dll'
else
  let g:vimproc_dll_path = $HOME . '/.vim/proc/proc_mac.so'
endif

set textwidth=0
set ambiwidth=double
"set number
set nonu
set autoindent
set iminsert=0
set titlestring=%<%f\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}\ \ %{fnamemodify(getcwd(),':~')}
set titlelen=200
set linespace=5
set antialias
set backupdir=~/.vim/backup
set directory=~/.vim/swp
set scrolloff=5
set wrap
set hlsearch
set smartindent
set timeout timeoutlen=300 ttimeoutlen=200
set shellslash
set incsearch
set laststatus=0
"set statusline=%3l%3p%%\ \|\ %<%t\ %m%=%c\|%R%Y%{'\|'.(&fenc!=''?&fenc:&enc).'\|'.&ff}
set statusline=%3l%4p%%\ \|\ %<%t\ %m\ %r%=%c\|%Y

" ubuntu だと画面がちらつく。mac だと音が出ちゃう。
if has('mac')
  "set vb t_vb=
  set vb
endif

set tabstop=2
set shiftwidth=2
set softtabstop=0
set expandtab
set noshowmatch
set matchpairs+=<:>
set shortmess=atTWIoO
set complete=.
set pumheight=10
set showcmd
set noshowmode
" 矩形選択中は行末にテキストがなくてもカーソルを行末以降に移動させることができる
set virtualedit+=block
set fileencodings=ucs-bom,utf-8,cp932,shift-jis,euc-jp
set fileformats=unix,dos

set ignorecase

"}}}

" auto command {{{
""""""""""""""""""""""""""""""""""
"         auto command           "
""""""""""""""""""""""""""""""""""
augroup MyGroup
  autocmd!
  au BufNewFile,BufRead *.scala setf scala
  "set autochdir
  au BufEnter * call s:all_bufenter_setting()

  autocmd FileType ruby,eruby,scala,javascript  :setlocal tabstop=2
  autocmd FileType ruby,eruby,scala,javascript  :setlocal shiftwidth=2
  autocmd FileType ruby,eruby,scala,javascript  :setlocal expandtab

  autocmd FileType java,c,cpp,cs :setlocal tabstop=4
  autocmd FileType java,c,cpp,cs :setlocal shiftwidth=4
  autocmd FileType java,c,cpp,cs :setlocal noexpandtab

  autocmd FileType help :setlocal noexpandtab

  autocmd BufRead,BufNewFile *.mkd  set filetype=markdown
  autocmd BufRead,BufNewFile *.md   set filetype=markdown
  " for uiki
  autocmd FileType uiki nnoremap <buffer> mq ggvG$:QuickRun<CR>

  autocmd BufRead,BufNewFile *.ecob set filetype=cobol

  autocmd FileType netrw setlocal buftype=nofile bufhidden=delete

  autocmd FileType unite        call s:unite_my_settings()
  autocmd FileType scratch      call s:scratch_my_settings()

  autocmd FileType note       call s:note_settings()

  autocmd FileType git :setlocal foldlevel=99

  autocmd FileType svn :setlocal noswapfile

  if !has('gui_running')
    autocmd InsertEnter,InsertLeave * set cursorline!
  endif
augroup END

function! s:note_settings()
  nnoremap <silent> <buffer> <C-l> :Unite outline -vertical -winwidth=50 -no-quit -no-start-insert -buffer-name=outline -hide-source-names -direction=rightbelow<CR>
endfunction


function! s:bg_settings()
  AlterCommand <buffer> q bd
endfunction

function! s:all_bufenter_setting()
  setlocal bufhidden=hide
  if &filetype == ''
    if expand("%") =~ '\[quickrun output\]'
      setfiletype quickrun
    else
      setfiletype txt
    endif
  endif

  if &modifiable && join(getline(1,3)) == ''
    setlocal fileencoding=utf-8
    setlocal fileformat=unix
    setlocal nomodified
  endif

  try
    execute ":lcd " . substitute(expand("%:p:h")," ",'\\ ','g')
  catch
  endtry
endfunction

" }}}

if exists('RmVimball')
  delcommand RmVimball
endif

" colors {{{
""""""""""""""""""""""""""""""""""
"            colors              "
""""""""""""""""""""""""""""""""""
hi Cursor  guifg=bg guibg=orange

hi tweetvim_reply ctermbg=5
hi tweetvim_appendix ctermfg=darkgray
hi PmenuSel ctermbg=darkblue ctermfg=white

hi J6uil_quotation ctermfg=gray

hi Error ctermbg=0 ctermfg=red

let java_ignore_javadoc = 1

"}}}

""""""""""""""""""""""""""""""""""
"             map                "
""""""""""""""""""""""""""""""""""

nnoremap I i<Space><Left>

nnoremap qq q
nnoremap q <Nop>

nnoremap <silent> U :<C-u>redo<CR>
"map bn    :bnext<CR>
"ウインドウのフォーカス移動
noremap wh <C-w>h
noremap wl <C-w>l
noremap wj <C-w>j
noremap wk <C-w>k
noremap <silent> gl :macaction selectNextWindow:<CR>
noremap <script> gh :macaction selectPreviousWindow:<CR>

nnoremap <silent> <Space>.   :<C-u>silent! edit   $MYVIMRC<Enter>
nnoremap <Space>s.  :<C-u>source $MYVIMRC<Enter>
nnoremap <Space>g.  :<C-u>edit   $MYGVIMRC<Enter>
nnoremap <Space>gs. :<C-u>source $MYGVIMRC<Enter>
nnoremap <Space>v.  :<C-u>edit   ~/.vimshrc<Enter>
nnoremap <Space>ss  :<C-u>Source %<Enter>

nnoremap <C-x><C-n> :setlocal nu!<CR>

inoremap <C-d> <Del>
cmap <C-d> <Del>

"nnoremap 0 ^
"nnoremap ^ 0

" C-kを押すと行末まで削除
inoremap <C-k> <C-o>D
inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

nnoremap gc `[v`]

"コマンドモードで Ctl + v で貼り付ける
cmap <C-v> <C-R>+
"挿入モードで Ctl + v で貼り付ける
imap <C-v> <C-R>+
"全て選択
nmap  <C-a><C-a> ggvG$
" gvim で q → bd をしてる用
nmap <C-q><C-q><C-q> ZQ

cmap <C-e> <End>
cmap <C-a> <HOME>
cmap <C-f> <Right>
cmap <C-b> <Left>
imap <C-e> <End>
imap <C-a> <ESC>^i
imap <C-f> <Right>
imap <C-b> <Left>

nnoremap <C-e> <End>
nnoremap <C-a> <HOME>
nnoremap <C-f> <Right>
nnoremap <C-b> <Left>
" カウントアップ
nnoremap <C-c> <C-a>

nmap <Leader><Leader>b <Plug>(openbrowser-open)

nnoremap <M-k> <C-y>
nnoremap <M-j> <C-e>
nnoremap <Leader>s :Scratch<CR>
nnoremap <Leader>w :WriteToFile<CR>
nnoremap <silent> <Leader>o :on<CR>
nnoremap <Leader><Leader> :Unite 
"nnoremap <Leader>g  :VimGrep **/*.* 
nnoremap <Leader>g :Unite grep:.: -no-quit -no-start-insert -direction=botright -buffer-name=grep -hide-source-names<CR>
nnoremap <Space>d :<C-u>pwd<CR>
"nnoremap <silent> <C-l> :Unite outline  -winheight=30 -buffer-name=outline<CR>
nnoremap <silent> <C-l> :Unite outline  -winwidth=40 -buffer-name=outline -hide-source-names<CR>
nnoremap <silent> <C-l><C-l> :Unite outline:!  -winheight=30 -buffer-name=outline<CR>
nnoremap <silent> <C-x><C-x> :TabNew<CR>
nnoremap <silent> <C-x><C-l> :tabnext<CR>
nnoremap <silent> <C-x><C-h> :tabprevious<CR>
nnoremap <silent> <C-f> :tabnext<CR>
nnoremap <silent> <C-b> :tabprevious<CR>
" エンコードを指定して開き直す
nnoremap <silent> <Space>r  :UniteResume<CR>
nnoremap <C-w>; <C-w>+
nnoremap w; <C-w>+
nnoremap w- <C-w>-
nnoremap wm 100<C-w>+
nnoremap man :Unite help<CR>
nnoremap <silent>co :Unite -no-quit -buffer-name=qflist qflist<CR>
"nnoremap <silent><Leader>r :UniteResume<CR>
nnoremap <silent><Leader>r :redraw!<CR> 
nnoremap <silent>on 999<C-w>+
nnoremap <silent><Leader><Leader>r :Unite yarm<CR>
"nnoremap <silent><Leader>l :Unite -vertical -winwidth=50 uiki<CR>
nnoremap <silent><Leader>l  :<C-u>Unite -buffer-name=note -hide-source-names -hide-status-line note<CR>
"nnoremap <silent><Leader>ll  :<C-u>Unite -buffer-name=note -hide-source-names -hide-status-line note/archive note<CR>
nnoremap <C-p> :Unite 

nnoremap <silent><C-h> :Unite history/command<CR>
nnoremap cn :cn<CR>
nnoremap cp :cp<CR>
nnoremap wp <C-w>p
nnoremap <C-]> g<C-]>
nnoremap <C-w> <Home>dw
nnoremap <silent> j  gj
nnoremap <silent> gj j
nnoremap <silent> k  gk
nnoremap <silent> gk k
"nnoremap 0 ^
"nnoremap 00 0
"nnoremap ^ 0
nnoremap $  g$
nnoremap g$ $

nnoremap L y$

cnoremap <C-p>  <Up>
cnoremap <Up>   <C-p>
cnoremap <C-n>  <Down>
cnoremap <Down> <C-n>

" for unite-rails
nnoremap <C-x><C-m> :Unite rails/model<CR>
nnoremap <C-x><C-c> :Unite rails/controller<CR>
nnoremap <C-x><C-j> :Unite rails/view<CR>
nnoremap <C-x><C-d> :Unite rails/db<CR>
nnoremap <C-x><C-f> :Unite rails/config<CR>
nnoremap <C-x> :Unite rails/

inoremap <C-x><C-x> <Esc>:Unite sudden-death -winheight=4 -hide-source-names<CR>

nnoremap Y y$

nnoremap <silent> <C-@><C-@> :Restart!<CR>

nmap <Leader>c <Plug>NERDCommenterToggle
" ターミナルだとなぜか起動時にインサートモードになるので

inoremap <C-s> <ESC>:w<CR>:echo "saved"<CR>
inoremap <silent> <C-o> <ESC>o
inoremap <C-j> <ESC>
inoremap jj <ESC>
noremap <silent> <C-j> <ESC>:noh<CR>
" cygwin だとなぜか insert モードに入る
if has('gui_running')
  noremap <silent> <ESC> <ESC>:noh<CR>
endif
inoremap kk <ESC>O
inoremap [[ []<Left>
inoremap <C-q> []<Left>

vnoremap <C-e> <End><Left>
vmap <Leader>c <Plug>NERDCommenterToggle
vmap <C-b> :Batch<CR>

cnoremap <C-j> <C-u><ESC>

vnoremap ch :s/\t/\|_=./g<CR>
vnoremap cb :s/\t/\|/g<CR>

" getchar() で挿入する文字を入力
nmap <leader>J <Plug>(jplus-getchar)
vmap <leader>J <Plug>(jplus-getchar)

" 文字の左右にスペースを付属させる
nmap <Space>J <Plug>(jplus-getchar-with-space)
vmap + <Plug>(jplus-getchar-with-space)

function! s:initialize_neocomplete() "{{{
  let g:neocomplete#enable_at_startup= 1
	if !exists('g:neocomplete#keyword_patterns')
	    let g:neocomplete#keyword_patterns = {}
	endif
	let g:neocomplete#keyword_patterns._ = '\h\w*'

	if !exists('g:neocomplete#sources#dictionary#dictionaries')
    let g:neocomplete#sources#dictionary#dictionaries = {}
  endif
  let dict = g:neocomplete#sources#dictionary#dictionaries
  "let dict._ = $HOME . '/.vim/dict/default.dict'
  "let dict.tweetvim_say =  $HOME . '/.tweetvim/screen_name,' .
                         "\ $HOME . '/.tweetvim/hash_tag,'
  
  let g:neocomplete#sources#buffer#disabled_pattern = '\.log\|\.log\.\|\.jax\|Log.txt'
  let g:neocomplete#enable_ignore_case = 0
  let g:neocomplete#enable_smart_case  = 1
  let g:neocomplete#enable_fuzzy_completion = 0

  call neocomplete#custom_source('_', 'sorters',  ['sorter_length'])
  call neocomplete#custom_source('_', 'matchers', ['matcher_head'])
  call neocomplete#custom_source('necosnippet', 'rank',  200)

  inoremap <expr><C-n>  pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>"
  inoremap <expr><CR>   pumvisible() ? "\<C-n>" . neocomplete#close_popup()  : "<CR>"
  inoremap <expr><C-e>  pumvisible() ? neocomplete#close_popup() : "<End>"
  inoremap <expr><C-c>  neocomplete#cancel_popup()
  inoremap <expr><C-u>  neocomplete#undo_completion()
  inoremap <expr><C-h>  neocomplete#smart_close_popup()."\<C-h>"
endfunction


if !has('win32unix')
  call s:initialize_neocomplete()
  call neocomplete#initialize()
endif

" }}}

"}}}

" ■ snippet 補完 {{{
imap <expr><C-l> pumvisible() ?
      \ "\<C-y><Plug>(neosnippet_expand_or_jump)"
      \ : "<Plug>(neosnippet_expand_or_jump)"
imap <C-l> <Plug>(neosnippet_expand_or_jump)
smap <C-l> <Plug>(neosnippet_expand_or_jump)

command! -nargs=* Nes NeoSnippetEdit <args>
"}}}

" open browser {{{
""""""""""""""""""""""""""""""""""
"        open browser            "
""""""""""""""""""""""""""""""""""

let g:openbrowser_short_message = 1

"}}}

" vimfiler {{{
""""""""""""""""""""""""""""""""""
"            vimfiler            "
""""""""""""""""""""""""""""""""""

let g:vimfiler_as_default_explorer = 1

"}}}

" unite {{{
""""""""""""""""""""""""""""""""""
"             unite              "
""""""""""""""""""""""""""""""""""

nnoremap <silent> <C-r>      :<C-u>Unite -buffer-name=file_mru file_mru -start-insert -hide-source-names<CR>
nnoremap <silent> <C-n>      :<C-u>Unite -buffer-name=buffer -hide-source-names buffer_tab<CR>
nnoremap <silent> <Leader>d  :<C-u>Unite -buffer-name=files -hide-source-names file file/new<CR>
nnoremap <silent> <Leader>b  :<C-u>Unite -buffer-name=bookmark -no-start-insert bookmark<CR>
nnoremap <silent> <C-t>      :<C-u>Unite -buffer-name=tags tags -start-insert -hide-source-names<CR>
nnoremap <Leader>f  :<C-u>Unite file_rec -input=

nnoremap <silent> <C-s> :Unite -buffer-name=history_yank history/yank<CR>

"let g:unite_source_history_yank_enable = 1
let g:unite_enable_start_insert = 1
" mru
let g:unite_source_file_mru_time_format    = ''
let g:unite_source_file_mru_ignore_pattern = '.*Application\ Data.*\|.*デスクトップ.*\|.*Local/Temp/.*\|\[quickrun output\]\|.*Local Settings/Temp/.*\|fugitive://\|\.git\|/private/var'
" unite ウインドウの高さ
let g:unite_winheight  = 10
let g:unite_split_rule = 'aboveleft'


"call s:unite_substitute('', '[[:alnum:]]', '*\0', 100)
call Unite_substitute('file', '^\~', substitute(substitute($HOME, '\\', '/', 'g'), ' ', '\\\\ ', 'g'), -200)
if has('win32')
  call Unite_substitute('file', '[^~.]\zs/', '*/*', 20)
  call Unite_substitute('file', '/\ze[^*]', '/*'  , 10)
else
  call Unite_substitute('file', '[[:alnum:]]', '*\0', -150)
endif

call Unite_substitute('file_mru', '[[:alnum:]]', '*\0', 100)
call Unite_substitute('file_mru', '[^~.]\zs/', '*/*'  , 20)
call Unite_substitute('file_mru', '/\ze[^*]', '/*'    , 10)

call unite#custom_filters('buffer,buffer_tab',
      \ ['matcher_file_name', 'sorter_default', 'converter_file_directory'])

call unite#custom#source('file', 'matchers', 'matcher_fussy')

call unite#custom_filters('file_mru',
      \ ['matcher_file_name', 'sorter_default', 'converter_file_directory'])

call unite#custom_filters('uiki',
      \ ['matcher_fussy', 'sorter_default', 'converter_default'])

call unite#custom_filters('bookmark',
      \ ['matcher_fussy', 'sorter_default', 'converter_bookmark'])

call unite#custom_filters('everything',
      \ ['matcher_file_name', 'sorter_default', 'converter_file_directory'])

let g:unite_source_outline_cache_dir = ''

call unite#custom_default_action('source/bookmark/directory' , 'vimfiler')

call unite#set_profile('buffer_tab,file,file_mru,everything', 'ignorecase', 1)

let my_absolute_path = {
\ 'is_selectable' : 1,
\ 'is_quit' : 0,
\ }
function! my_absolute_path.func(candidates)
  let candidate = a:candidates[0]
  let path      = candidate.action__directory
  if candidate.kind == 'directory'
    let path = fnamemodify(path . '/../', ':p')
  else
    let path = fnamemodify(path, ':p:h') . '/'
  end
  call unite#start([['file'], ['file/new']],unite#get_context())
  call unite#mappings#narrowing(path)
endfunction
call unite#custom_action('file', 'absolute_path', my_absolute_path)
unlet my_absolute_path

function! s:unite_my_settings()

  imap <buffer> jj <Plug>(unite_insert_leave)
  imap <buffer> <C-j> <Esc>c<Plug>(unite_all_exit)
  imap <buffer> <ESC> <Esc><Plug>(unite_all_exit)
  imap <buffer> <C-w> <Plug>(unite_delete_backward_path)
  inoremap <buffer><expr> <C-g> unite#do_action('grep_directory')
  inoremap <buffer><expr> <C-@> unite#do_action('absolute_path')
  inoremap <buffer><expr> <C-x><C-i> unite#do_action('insert')
  inoremap <buffer><expr> <C-y> unite#do_action('yank')
	noremap <silent><buffer><expr> <C-x><C-i> unite#do_action('insert')
  imap <buffer> <C-e> <Enter>
  nmap <buffer> <C-n> <Plug>(unite_loop_cursor_down)
  nmap <buffer> <C-p> <Plug>(unite_loop_cursor_up)
  nmap <buffer> <C-j> <Plug>(unite_exit)
  imap <buffer> <C-r> <Plug>(unite_redraw)

  inoremap <buffer> <C-f> <Right>
  inoremap <buffer> <C-b> <Left>
  inoremap <silent><buffer><expr> <C-d> unite#do_action('delete')
  inoremap <silent><buffer><expr> <C-s> unite#do_action('rec_parent/async')

  map <silent><buffer> a <Plug>(unite_insert_enter)

  "startinsert
endfunction


let g:unite_source_alias_aliases = {
\   "gvalue" : {
\       "source" : "output",
\       "args" : 'echo join(map(keys(g:),"''g:''.v:val"),"\n")'
\   }
\}

"}}}

""""""""""""""""""""""""""""""""""
"             misc               "
""""""""""""""""""""""""""""""""""
let g:scratchBackupFile=$HOME . "/.scratch.txt"
" ubuntu の時だけ
if !has('mac') && !has('win32') && !has('win32unix')
  inoremap <silent> <esc> <esc>:call ForceImeOff()<cr>
  inoremap <silent> <C-[> <esc>:call ForceImeOff()<cr>
  inoremap <silent> <C-c> <esc>:call ForceImeOff()<cr>
  function! ForceImeOff()
    let imeoff = system('xvkbd -text "\[Control]\[Shift]\[space]" > /dev/null 2>&1')
  endfunction
endif

command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>')
function! s:ChangeCurrentDir(directory, bang)

  if &filetype == 'vimfiler'
    lcd `=b:vimfiler.current_dir`
    return
  endif

  if a:directory == ''
    lcd %:p:h
  else
    execute 'lcd' . a:directory
  endif

  if a:bang == ''
    pwd
  endif
endfunction

" Change current directory.
nnoremap <silent> <Space>cd :<C-u>CD<CR>


" tweetvim {{{
""""""""""""""""""""""""""""""
"          tweetvim          "
""""""""""""""""""""""""""""""

" tweetvim
nnoremap <silent> s           :exe ":silent TweetVimSay"<CR>
nnoremap <silent> <Space>re   :<C-u>TweetVimMentions<CR>
nnoremap <silent> <Space>a    :TweetVimListStatuses all<CR>
nnoremap <silent> t  :Unite -buffer-name=tweetvim tweetvim<CR>
nnoremap <silent> ta :TweetVimHomeTimeline<CR>
nnoremap <silent> th :TweetVimHomeTimeline<CR>
nnoremap <silent> tm :TweetVimMentions<CR>



"let g:tweetvim_default_account = 'tottoruby'
let g:tweetvim_display_source = 1
let g:tweetvim_original_hi = 0

if !has('gui_running')
  let g:tweetvim_display_source  = 0
  let g:tweetvim_empty_separator = 1
endif

augroup mygroup-tweetvim
  autocmd!
  autocmd FileType tweetvim_say call s:tweetvim_say_my_settings()
augroup END
" for tweetvim say
function! s:tweetvim_say_my_settings()
  AlterCommand <buffer> q bd!<CR>
  nnoremap <buffer> <silent> <C-j> :bd!<CR>
  if !has('gui_running')
    nnoremap <buffer> <silent> <esc> :bd!<CR>
  endif
"  inoremap <buffer> <C-x><C-d> <ESC>:TweetVimBitly<CR>
endfunction



"}}}

" quickrun {{{
"
"
silent! nmap <Leader>q :QuickRun<CR>

augroup mygroup-quickrun
  autocmd!
  autocmd FileType quickrun    call s:quickrun_setting()
augroup END

function! s:quickrun_setting()
  nmap <buffer> <C-j> :bd!<CR>
endfunction

if has('mac')
  let g:quickrun_config = {
        \ '*' : {'into' : 0},
        \ 'uiki': {
        \   'exec'      : 'ucloth %s',
        \   'outputter' : 'browser'  ,
        \ },
        \}
"  let g:quickrun_config['cs'] = {
"        \ 'command' : 'dmcs',
"        \ 'runmode' : 'simple',
"        \ 'exec' : ['%c %s > /dev/null', 'mono "%S:p:r:gs?/?\\?.exe" %a', ':call delete("%S:p:r.exe")'],
"        \ 'tempfile' : '%{tempname()}.cs',
"        \ }
else
  let g:quickrun_config = {
        \ '*' : {'into' : 0},
        \ 'uiki': {
        \   'exec'      : 'ucloth %s',
        \   'outputter' : 'browser'  ,
        \   'region' : {
        \     'first': [1, 0, 0],
        \     'last' :  [line('$'), 0, 0],
        \     'wise' : 'V',
        \    },
        \ },
        \}
"  let g:quickrun_config['cs'] = {
"        \ 'command' : 'csc',
"        \ 'runmode' : 'simple',
"        \ 'output_encode' : 'cp932:utf-8',
"        \ 'exec' : ['%c /nologo /reference:System.dll %s:gs?/?\\? > /dev/null', '"%S:p:r:gs?/?\\?.exe" %a', ':call delete("%S:p:r.exe")'],
"        \ 'tempfile' : '{tempname()}.cs',
"        \ }
endif

let g:quickrun_config.markdown = {
      \ 'exec'      : 'kramdown %s',
      \ 'outputter' : 'browser',
      \ }


if has('win32')
  let g:quickrun_config['java'] = {
        \ 'output_encode' : 'cp932:utf-8',
        \ }
endif

"}}}

nnoremap <Space>full :call FullScreen()<Enter>
function! FullScreen()
  set columns=195
  set lines=43
endfunction


" カーソル位置の highlight グループを取得する．
command! -nargs=0 GetHighlightingGroup echo 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '> trans<' . synIDattr(synID(line('.'),col('.'),0),'name') . '> lo<' . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'

" Load settings for each location.
augroup vimrc-local
  autocmd!
  "autocmd BufNewFile,BufReadPost,BufWinEnter * call s:vimrc_local(expand('<afile>:p:h'))
  autocmd BufNewFile,BufReadPost * call s:vimrc_local(expand('<afile>:p:h'))
augroup END

command! FindTags call s:vimrc_local(expand('<afile>:p:h'))
function! s:vimrc_local(loc)
"  let files = findfile('.vimrc.local', escape(a:loc, ' ') . ';', -1)
"  for i in reverse(filter(files, 'filereadable(v:val)'))
"    source `=i`
"  endfor
  let &l:tags=findfile('.tags' , '.;')
"  let &tags=findfile('.tags' , '.;')
endfunction

"http://vim-users.jp/2010/03/hack130/
command! -complete=file -nargs=+ VimGrep  call s:grep([<f-args>])
function! s:grep(args)
  execute 'vimgrep' '/'.a:args[-1].'/' join(a:args[:-2]) | :Unite qflist
endfunction

if has('mac')
  let g:restart_vim_progname = "MacVim"
end

" indent xml
command! IndentXML call s:indent_xml()
function! s:indent_xml()
  let xml = util#xml#indent(join(getline(1,'$'),"\n"))
  silent %delete _
  set paste
  execute 'normal i' . xml
  set nopaste
  :0
endfunction
" xpath
command! -nargs=1 XPath let @" = util#xml#xpath_text(join(getline(1,'$'),"\n") , <f-args>) | echo @"

command! MoveLeft call s:MoveLeft()
function! s:MoveLeft()
  winpos 0 0
  set lines=999
endfunction
function! s:scratch_my_settings()
  AlterCommand <buffer> q :Scratch<CR>
endfunction

command! CloseAll call s:close_all() "{{{
function! s:close_all()
  let l:bufnr = 1
  while l:bufnr <= bufnr('$')
    if buflisted(l:bufnr) && bufname(l:bufnr) !~ "vimshell"
      exec "bd! " . l:bufnr
    endif
    let l:bufnr += 1
  endwhile
endfunction "}}}

command! WriteToFile call s:write_to_file() " {{{
function! s:write_to_file()
  if &filetype == 'yarm'
    echo 'please use :w'
    return
  end
  try
    silent w
    let msg = ' write to ' . bufname('%') . ' ... OK !!! '
    echohl CursorLine| echo msg | echohl None
  endtry
endfunction "}}}

command! GoFmt execute ':VimProcBang gofmt -w %' | execute ':edit! %'

command! TabNew :call s:tabnew() "{{{
function! s:tabnew()
  tabnew
  Scratch
  wincmd p
  bd
endfunction "}}}

"■ color for cygwin {{{
if has('win32unix')
  hi Pmenu     ctermfg=LightYellow  ctermbg=black cterm=none
  hi PmenuSel  ctermfg=232          ctermbg=magenta
  hi Special   ctermfg=green        cterm=none
  hi PreProc   ctermfg=green        cterm=none
endif
" }}}

" ■ Kwbd {{{
"here is a more exotic version of my original Kwbd script
"delete the buffer; keep windows; create a scratch buffer if no buffers left
function! s:Kwbd(kwbdStage)
  if(a:kwbdStage == 1)
    if(!buflisted(winbufnr(0)))
      bd!
      return
    endif
    let s:kwbdBufNum = bufnr("%")
    let s:kwbdWinNum = winnr()
    windo call s:Kwbd(2)
    execute s:kwbdWinNum . 'wincmd w'
    let s:buflistedLeft = 0
    let s:bufFinalJump = 0
    let l:nBufs = bufnr("$")
    let l:i = 1
    while(l:i <= l:nBufs)
      if(l:i != s:kwbdBufNum)
        if(buflisted(l:i))
          let s:buflistedLeft = s:buflistedLeft + 1
        else
          if(bufexists(l:i) && !strlen(bufname(l:i)) && !s:bufFinalJump)
            let s:bufFinalJump = l:i
          endif
        endif
      endif
      let l:i = l:i + 1
    endwhile
    if(!s:buflistedLeft)
      if(s:bufFinalJump)
        windo if(buflisted(winbufnr(0))) | execute "b! " . s:bufFinalJump | endif
      else
        enew
        let l:newBuf = bufnr("%")
        windo if(buflisted(winbufnr(0))) | execute "b! " . l:newBuf | endif
      endif
      execute s:kwbdWinNum . 'wincmd w'
    endif
    if(buflisted(s:kwbdBufNum) || s:kwbdBufNum == bufnr("%"))
      execute "bd! " . s:kwbdBufNum
    endif
    if(!s:buflistedLeft)
      setlocal buflisted
      setlocal bufhidden=delete
      setlocal buftype=nofile
      setlocal noswapfile
      setlocal filetype=scratch
    endif
  else
    if(bufnr("%") == s:kwbdBufNum)
      let prevbufvar = bufnr("#")
      if(prevbufvar > 0 && buflisted(prevbufvar) && prevbufvar != s:kwbdBufNum)
        b #
      else
        bn
      endif
    endif
  endif
endfunction

command! Kwbd call <SID>Kwbd(1)
" }}}

if filereadable($HOME . '/.vimrc_local_after')
  source ~/.vimrc_local_after
endif

inoremap <silent><C-x><C-s> <Esc>:call <SID>toggle_status()<CR>a
nnoremap <silent><C-x><C-s> :call <SID>toggle_status()<CR>

function! s:toggle_status()
  if &laststatus == 2 
    let &laststatus = 0
  else
    let &laststatus = 2
    if winheight('%') < 3
      execute '3 wincmd _'
    endif
  endif
endfunction

" ■ proxy {{{
function! s:off_proxy()
  let $http_proxy  = ""
  let $https_proxy = ""
  let $HTTP_PROXY  = ""
  let $HTTPS_PROXY = ""
endfunction
command! OffProxy call <SID>off_proxy()
" }}}


" after {{{
""""""""""""""""""""""""""
"        after           "
""""""""""""""""""""""""""

if filereadable($HOME . '/.vimrc_local_after')
  source ~/.vimrc_local_after
endif

"}}}

" vim: foldmethod=marker
