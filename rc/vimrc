"
" Last Modified: 21 Dec 2010
"
""""""""""""""""""""""""""""""""""
"         core settings          "
""""""""""""""""""""""""""""""""""

if expand("%") == ".git/COMMIT_EDITMSG"
  finish
endif

filetype plugin indent on
syntax enable
colorscheme desert
set runtimepath+=~/.vim
set runtimepath+=~/.vim/plugins/*
set runtimepath+=~/.vim/gitplugins/*
let g:vimball_home = "~/.vim"

call altercmd#load()

if &termencoding == ''
  let &termencoding="utf-8"
"  let &termencoding="cp932"
endif

let mapleader = "m"

""""""""""""""""""""""""""""""""""
"        init variables          "
""""""""""""""""""""""""""""""""""

if !exists('g:use_fuzzy_finder')
  let g:use_fuzzy_finder = 0
endif

""""""""""""""""""""""""""""""""""
"           settings             "
""""""""""""""""""""""""""""""""""


if filereadable($HOME . '/.vimrc_local')
  source ~/.vimrc_local
endif

if has('win32')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/proc_win.dll'
elseif has('win32unix')
  let g:vimproc_dll_path = $HOME . '/.vim/proc/proc_cygwin.dll'
else
  let g:vimproc_dll_path = $HOME . '/.vim/proc/proc_mac.so'
endif

set ambiwidth=double
set nu
set autoindent
set iminsert=0
set titlestring=%<%f\ %m%r%h%w%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}　-　%{getcwd()}
set titlelen=200
set linespace=2
set antialias
"set nobackup
set backupdir=~/.vim/backup
set directory=~/.vim/swp
"オートインデント時にタブが2つ入ることを防ぐ
set ts=4 sw=4 sts=0
set scrolloff=5
set wrap
set hlsearch
set smartindent
set timeout timeoutlen=300 ttimeoutlen=200
set shellslash
set incsearch
"set cmdheight=1

" ubuntu だと画面がちらつく。mac だと音が出ちゃう。
if has('mac')
  set vb t_vb=
endif

set tabstop=2
set shiftwidth=2
set expandtab
set noshowmatch
set matchpairs+=<:>
set shortmess+=I
set complete=.
set pumheight=10
set showcmd
" 矩形選択中は行末にテキストがなくてもカーソルを行末以降に移動させることができる
set virtualedit+=block
set fileencodings=utf-8,cp932,shift-jis,euc-jp
set fileformats=unix,dos
""""""""""""""""""""""""""""""""""
"         auto command           "
""""""""""""""""""""""""""""""""""
augroup MyGroup
  autocmd! MyGroup
  au BufWritePre * call s:change_last_mod_date()
  au BufNewFile,BufRead *.scala setf scala
  "set autochdir
  au BufEnter * call s:all_bufenter_setting()
  " for ruby
  autocmd FileType ruby  :setlocal tabstop=2
  autocmd FileType ruby  :setlocal shiftwidth=2
  autocmd FileType ruby  :setlocal expandtab
  " for eruby
  autocmd FileType eruby :setlocal tabstop=2
  autocmd FileType eruby :setlocal shiftwidth=2
  autocmd FileType eruby :setlocal expandtab
  " for scala
  autocmd FileType scala :setlocal tabstop=2
  autocmd FileType scala :setlocal shiftwidth=2
  autocmd FileType scala :setlocal expandtab
  " for vim
  autocmd FileType scala :setlocal tabstop=4
  autocmd FileType scala :setlocal shiftwidth=4
  autocmd FileType scala :setlocal noexpandtab
  " for java
  autocmd FileType java :setlocal tabstop=4
  autocmd FileType java :setlocal shiftwidth=4
  autocmd FileType java :setlocal noexpandtab
  " for javascript
  autocmd FileType javascript :setlocal tabstop=2
  autocmd FileType javascript :setlocal shiftwidth=2
  autocmd FileType javascript :setlocal expandtab

  autocmd FileType netrw setlocal buftype=nofile bufhidden=delete

  autocmd FileType fuf NeoComplCacheLock
  autocmd FileType vimwiki NeoComplCacheLock
  autocmd FileType howm_memo NeoComplCacheLock

  autocmd FileType vimshell call s:vimshell_filetype_settings()

  autocmd FileType unite    call s:unite_my_settings()
  autocmd FileType fuf      call s:fuf_my_settings()
  autocmd FileType scratch  call s:scratch_my_settings()
  autocmd FileType twitvim  call s:twitvim_my_settings()
  autocmd FileType twitvim_say  call s:twitvim_say_my_settings()

  autocmd CmdwinEnter * call s:init_cmdwin()

  autocmd FileType lingr-rooms    :setlocal nonu
  autocmd FileType lingr-rooms    :setlocal nowrap
  autocmd FileType lingr-members  :setlocal nonu
  autocmd FileType lingr-members  :setlocal nowrap
  autocmd FileType lingr-messages :setlocal nonu
  autocmd FileType lingr-messages call s:lingr_messages_setting()
  autocmd FileType lingr-say      call s:lingr_say_setting()

  autocmd FileType quickrun       call s:quickrun_setting()
  autocmd FileType qf             call s:qfix_howm_setting()
augroup END

function! s:all_bufenter_setting()
  setlocal bufhidden=hide
  if &filetype =~ 'howm.*'
    return
  endif
  if &filetype == ''
    if expand("%") =~ '\[quickrun output\]'
      setfiletype quickrun
    else
      setfiletype txt
    endif
  endif

  if &modifiable && join(getline(1,3)) == ''
    setlocal fileencoding=utf-8
    setlocal nomodified
  endif

  execute ":lcd " . substitute(expand("%:p:h")," ","\\\\ ","g")
endfunction
"
" Last Change を保存時に変更する
"
function! s:change_last_mod_date()
  let lineno = line(".")
  let colno  = col(".")
  :1
  let language =  v:lc_time
  execute ':silent! language time C'
  let time = '" Last Modified: ' . strftime("%d %b %Y")
  " 同じだったらなにもしない
  if !search(time , '' , 5)
    try
      execute '1,5s/" Last Modified:.*/' . time . '/'
    catch
    endtry
  endif
  execute ':silent! language time ' . language
  call cursor(lineno , colno)
endfunction

""""""""""""""""""""""""""""""""""
"            colors              "
""""""""""""""""""""""""""""""""""
hi Cursor	  guifg=bg	guibg=orange
" lingr
hi link lingrMessagesSpeaker Statement
hi link lingrRoomsActive     Statement
" wimwiki
hi link VimwikiPre Normal
""""""""""""""""""""""""""""""""""
"             map                "
""""""""""""""""""""""""""""""""""
map <silent> <S-u> :redo<CR>
map bn    :bnext<CR>
"ウインドウのフォーカス移動
map  wh <C-w>h
map  wl <C-w>l
map  wj <C-w>j
map  wk <C-w>k
map gl :macaction selectNextWindow:<CR>
map gh :macaction selectPreviousWindow:<CR>

nnoremap <Space>.   :<C-u>edit   $MYVIMRC<Enter>
nnoremap <Space>s.  :<C-u>source $MYVIMRC<Enter>
nnoremap <Space>g.  :<C-u>edit   $MYGVIMRC<Enter>
noremap  <Space>gs. :<C-u>source $MYGVIMRC<Enter>
noremap  <Space>v.  :<C-u>edit   ~/.vimshrc<Enter>
inoremap <C-d> <Del>
cmap <C-d> <Del>

inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

"コマンドモードで Ctl + v で貼り付ける
cmap <C-v> <C-R>+
"挿入モードで Ctl + v で貼り付ける
imap <C-v> <C-R>+
"全て選択
map  <C-a><C-a> ggvG$
"貼り付け
"map  <C-v> "+gP
" gvim で q → bd をしてる用
map <C-q><C-q><C-q> ZQ

cmap <C-e> <End>
cmap <C-a> <HOME>
cmap <C-f> <Right>
cmap <C-b> <Left>
imap <C-e> <End>
imap <C-a> <HOME>
imap <C-f> <Right>
imap <C-b> <Left>

nnoremap <C-e> <End>
nnoremap <C-a> <HOME>
nnoremap <C-f> <Right>
nnoremap <C-b> <Left>
"map <C-e> :Tlist<CR>

nnoremap <M-k> <C-y>
nnoremap <M-j> <C-e>
"nnoremap <C-s> :Scratch<CR>
nnoremap <Leader>s :Scratch<CR>
"nnoremap <Leader>s :sp ~/.[scratch]<CR>
nnoremap <Leader>v :VimShell<CR>
nnoremap <Leader>w :w<CR>
nnoremap <silent> <Leader>o :on<CR>
"nnoremap <Leader><Leader> <C-]>
"nnoremap <silent> <Leader><Leader> :Unite file -buffer-name=file<CR>
nnoremap <Leader><Leader> :Unite 
nnoremap <Leader>g  :VimGrep **/*.* 
nnoremap <Space>d :<C-u>pwd<CR>
"nnoremap <silent> <C-l> :FufBufferTag<CR>
nnoremap <silent> <C-l> :Unite outline<CR>
nnoremap <silent> <C-x><C-x> :tabnew<CR>
nnoremap <silent> <C-x><C-l> :tabnext<CR>
nnoremap <silent> <C-x><C-h> :tabprevious<CR>
" エンコードを指定して開き直す
nnoremap <Space>r   :e ++enc=
nnoremap <C-w>; <C-w>+
nnoremap w; <C-w>+
nnoremap w- <C-w>-
nnoremap wm 100<C-w>+
nnoremap man :Unite help<CR>
nnoremap <silent>co :Unite -no-quit qflist<CR>
nnoremap <silent><Leader>r :UniteResume<CR>
nnoremap <silent>on 999<C-w>+
nnoremap <Space>g :<C-u>call QFixHowmSearchInput("QFixHowm Grep : ", 0)<CR><C-u>
nnoremap <Space>a :<C-u>call QFixHowmListAllTitle(g:QFixHowm_Title, 0)<CR>
nnoremap <silent><Leader><Leader>r :Unite redmine<CR>
nnoremap <silent><Leader><Leader>h :Unite help<CR>
nnoremap <silent><Leader><Leader>w :execute ':edit! ' . g:unite_uiki_path . '/FrontPage.uiki'<CR>
nnoremap <silent><Leader><Leader>u :Unite uiki<CR>

nmap <Leader>c <Plug>NERDCommenterToggle
" ターミナルだとなぜか起動時にインサートモードになるので
if has('gui_running')
  nnoremap <silent> <ESC> :noh<CR>
endif

inoremap <silent><C-o> <ESC>o
inoremap <C-j> <ESC>
inoremap jj <ESC>
noremap <silent> <C-j> <ESC>:noh<CR>
inoremap kk <ESC><S-o>
inoremap () ()<Left>
"inoremap {} {}<Left>
inoremap [] []<Left>
inoremap "" ""<Left>
inoremap '' ''<Left>
inoremap <> <><Left>

vnoremap <C-e> <End><Left>
vmap <Leader>c <Plug>NERDCommenterToggle
vmap <C-b> :Batch<CR>

cnoremap <C-j> <C-u><ESC>

""""""""""""""""""""""""""""""""""
"        neo complcache          "
""""""""""""""""""""""""""""""""""
" 起動時に有効
let g:neocomplcache_enable_at_startup = 1

" snippet ファイルの保存先
let g:neocomplcache_snippets_dir='~/.vim/snippets'
" dictionary
if !exists('g:neocomplcache_dictionary_filetype_lists')
  let g:neocomplcache_dictionary_filetype_lists = {}
endif
let neco_dic = g:neocomplcache_dictionary_filetype_lists
let neco_dic.objc        = $HOME . '/.vim/dict/objc.dict'
let neco_dic.javascript  = $HOME . '/.vim/dict/js.dict'
let neco_dic.ruby        = $HOME . '/.vim/dict/ruby.dict'
let neco_dic.eruby       = $HOME . '/.vim/dict/ruby.dict'
let neco_dic.java        = $HOME . '/.vim/dict/java.dict'
"let neco_dic.vimshell    = $HOME . '/.vimshell/command-history'
let neco_dic.twitvim_say = $HOME . '/.twitvim.users,' . 
                            \ $HOME . '/.twitvim.tags'
let neco_dic.default     = $HOME . '/.vim/dict/default.dict'

" 日本語をキャッシュしない
if !exists('g:neocomplcache_keyword_patterns')
	let g:neocomplcache_keyword_patterns = {}
endif
let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
" 補完候補の数
"let g:neocomplcache_max_list = 5
" 補完しなくなる文字数
let g:neocomplcache_enable_auto_select = 1
" 補完しないパターン
let g:neocomplcache_disable_caching_buffer_name_pattern = '.log\|.jax\|.howm'
" 自動補完しないパターン
let g:neocomplcache_lock_buffer_name_pattern = '.log\|.*quickrun.*\|.jax'
" 自動選択しないパターン
let g:neocomplcache_disable_auto_select_buffer_name_pattern = 'vimshell'
" キャッシュ中に、メッセージをCommand-lineに表示しない
let g:neocomplcache_enable_caching_message = 0
" キー入力時にキーワード補完を行う入力数を制御する。
let g:neocomplcache_auto_completion_start_length = 3
"入力に大文字が含まれている場合は、大文字・小文字を無視しない 
"let g:neocomplcache_enable_smart_case = 1
" セパレータ補完
"let g:neocomplcache_enable_auto_delimiter = 1
" 辞書読み込
noremap  <Space>d. :<C-u>NeoComplCacheCachingDictionary<Enter>
" <TAB> completion.
inoremap <expr><TAB> pumvisible() ? "\<C-n>" : "\<TAB>"
" C-jでオムニ補完
"inoremap <expr> <C-j> &filetype == 'vim' ? "\<C-x>\<C-v>\<C-p>" : "\<C-x>\<C-o>\<C-p>"
" C-kを押すと行末まで削除
inoremap <C-k> <C-o>D
" C-nでneocomplcache補完
inoremap <expr><C-n>  pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>"
" C-pでkeyword補完
"inoremap <expr><C-p> pumvisible() ? "\<C-p>" : "\<C-p>\<C-n>"
" 補完候補が出ていたら確定、なければ改行
inoremap <expr><CR>  pumvisible() ? neocomplcache#close_popup() : "<CR>"
"inoremap <expr><C-e> pumvisible() ? neocomplcache#close_popup() : "<End>"
" 補完をキャンセル
inoremap <expr><C-c>  neocomplcache#cancel_popup()
" 補完をアンドゥ
inoremap <expr><C-u>  neocomplcache#undo_completion()

inoremap <silent> <ESC> <ESC>:set iminsert=0<CR>
"map <silent> <ESC> <ESC>:set iminsert=0<CR>
" snippet 補完
imap <silent> <C-l> <Plug>(neocomplcache_snippets_expand)
smap <silent> <C-l> <Plug>(neocomplcache_snippets_expand)
command! -nargs=* Nes NeoComplCacheEditSnippets <args>
command! -nargs=* Nel NeoComplCacheLock <args>
command! -nargs=* NSource NeoComplCachePrintSource


""""""""""""""""""""""""""""""""""
"            vimshell            "
""""""""""""""""""""""""""""""""""

let g:vimshell_prompt = '$ '
let g:vimshell_user_prompt = "printf('%s','')\ngetcwd()"
let g:vimshell_edit_no_split = 1
let g:vimshell_interactive_cygwin_path = 'D:/develop/dev/cygwin/bin'
let g:vimshell_interactive_cygwin_home = 'D:/develop/dev/cygwin/home/Administrator'
let g:vimshell_split_command = 'split'
" ディレクトリの補完時に/を補います
let g:vimshell_enable_auto_slash = 1
"let g:vimshell_split_command = "vsplit"
if !exists('g:vimshell_interactive_cygwin_commands')
  let g:vimshell_interactive_cygwin_commands = {}
endif
let g:vimshell_interactive_cygwin_commands['git'] = {
  \ 'name' : 'git',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
let g:vimshell_interactive_cygwin_commands['termtter'] = {
  \ 'name' : 'termtter',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
let g:vimshell_interactive_cygwin_commands['irb'] = {
  \ 'name' : 'irb',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
let g:vimshell_interactive_cygwin_commands['rake'] = {
  \ 'name' : 'rake',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
let g:vimshell_interactive_cygwin_commands['telnet'] = {
  \ 'name' : 'telnet',
  \ 'kind' : 'execute',
  \ 'description' : 'git [{options}...] {command}',
\}
call vimshell#set_execute_file('txt,vim,xml,java', 'vim')

function! s:vimshell_filetype_settings()
  "imap <buffer><expr> <CR> (pumvisible() ? "<C-y>" : "<Plug>(vimshell_enter)")
  "imap <buffer><expr> <CR> (pumvisible() ? "<C-y><Tab>" : "<Plug>(vimshell_enter)")
  inoremap <buffer> <C-x> <ESC><C-w>h:on<CR>
  nnoremap <buffer> <CR> Go$ 
  imap <buffer> <C-x>     <ESC><C-w>h:on<CR>
  inoremap <C-v> <C-R>+
  inoremap <buffer><expr><C-h> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
  imap <buffer> <C-o> <Plug>(vimshell_enter)
  inoremap <buffer> <C-l> <C-y>
  imap <buffer> <C-s> <Plug>(vimshell_history_complete_whole)
  imap <buffer> <C-h> <Plug>(vimshell_delete_backward_char)
  "nunmap <buffer> <C-d>
  nunm <buffer> q
 	call vimshell#hook#set('preexec'  , ['g:vimshell_preexec'])
	call vimshell#hook#set('preprompt', ['g:vimshell_preprompt'])

  if g:use_fuzzy_finder == 1
    inoremap <buffer> <silent> <C-n>  <ESC>:<C-u>FufBuffer<CR>
    inoremap <buffer> <silent> <C-r>  <ESC>:<C-u>FufMruFile<CR>
    nnoremap <buffer><silent> <C-n>  :<C-u>FufBuffer<CR>
    inoremap <C-x><C-f> <Esc>:FufFile **/
  else
    inoremap <buffer> <silent> <C-n>  <ESC>:<C-u>Unite buffer_tab <CR>
    inoremap <buffer> <silent> <C-r>  <ESC>:<C-u>Unite file_mru -start-insert<CR>
    nnoremap <buffer><silent> <C-n>  :<C-u>Unite buffer_tab <CR>
    inoremap <C-x><C-f> <Esc>:Unite file_rec -input=
  endif


  hi VimShellPrompt guifg=#8ac6f2 gui=NONE
  NeoComplCacheAutoCompletionLength 3
endfunction
" vim コマンド実行前処理
function! g:vimshell_preexec(cmdline, context)
  " 改行する
  if a:cmdline =~ "^vim .*"
    " ホントは色付のユーザプロンプトを出したい
    call append('$', "")
    call append('$', vimshell#get_prompt())
    execute "normal G"
  endif
  return a:cmdline
endfunction
" vim コマンド実行後
function! g:vimshell_preprompt(args, context)
"  for key in keys(a:args)
"    call append('$', key . '=' . a:args[key])
"  endfor
   
"  if a:cmdline =~ "^vim .*"
"    on
"  endif
"  return a:cmdline
endfunction


function! s:vimshell_my_settings_buf_leave()
  echoerr "hello"
  "<ESC><CR>
  
  "execute "\<ESC>\<CR>"
  "startinsert!
endfunction


""""""""""""""""""""""""""""""""""
"            vimfiler            "
""""""""""""""""""""""""""""""""""

let g:vimfiler_as_default_explorer = 1

""""""""""""""""""""""""""""""""""
"      unite or fuzzyfinder      "
""""""""""""""""""""""""""""""""""
let mru_ignore = '.*\/$\|.*Application\ Data.*\|.*デスクトップ.*\|.*Local/Temp/.*\|\.howm\|.*\.git.*\|\[quickrun output\]'
"let g:fuf_keyOpen = ":"
"let g:fuf_maxMenuWidth = 90
let g:fuf_modesDisable     = ['mrucmd']
let g:fuf_timeFormat       = ''
let g:fuf_keyOpenVsplit    = '<C-v>'
let g:fuf_keyOpenSplit     = '<C-k>'
let g:fuf_buffer_keyDelete = '<C-d>'
let g:fuf_enumeratingLimit = 20
let g:fuf_mrufile_exclude = mru_ignore
let g:fuf_mrufile_maxItem = 1000

if g:use_fuzzy_finder == 1
  " 読み込んだことにしたいけどエラー出るのでコメントアウト
  "let g:loaded_unite = 1

  "nnoremap <silent> <Leader>d :<C-u>CD<CR>:FufFile<CR>
  nnoremap <silent> <C-r> :FufMruFile<CR>
  nnoremap <silent> <C-n> :FufBuffer<CR>
  nnoremap <silent> <Leader>d :<C-u>FufFile<CR>
  nnoremap <Leader>f :FufFile **/
  nnoremap <C-x><C-f> <Esc>:FufFile **/
  nnoremap <C-x><C-f><C-f> <Esc>:FufFile! **/
  inoremap <C-x><C-f> <Esc>:FufFile **/
  inoremap <C-x><C-f><C-f> <Esc>:FufFile! **/
  nnoremap <C-x><C-d> <Esc>:FufDir **/
  nnoremap <C-x><C-d><C-d> <Esc>:FufDir! **/
  inoremap <C-x><C-d> <Esc>:FufDir **/
  inoremap <C-x><C-d><C-d> <Esc>:FufDir! **/
  nnoremap <silent> <Leader>b :FufBookmarkDir<CR>
  nnoremap <silent> <C-t> :FufTag<CR>
else
  " 読み込んだことにする
  let g:fuf_modesDisable = ['mrucmd','mrufile','file','coveragefile']

  nnoremap <silent> <C-r>      :<C-u>Unite file_mru -start-insert<CR>
  nnoremap <silent> <C-n>      :<C-u>Unite buffer_tab <CR>
  nnoremap <silent> <Leader>d  :<C-u>Unite -buffer-name=file file<CR>
  nnoremap <silent> <Leader>b  :<C-u>Unite bookmark<CR>
  nnoremap <silent> <C-t>      :<C-u>Unite tags -start-insert<CR>
  nnoremap <Leader>f  :<C-u>Unite file_rec -input=
  nnoremap <C-x><C-f>  :<C-u>Unite file_rec -input=
  inoremap <C-x><C-f> :<C-u>Unite file_rec -input=
end

nnoremap <silent> <Leader>u  :<C-u>Unite buffer_tab file file_mru bookmark<CR>

"let g:unite_update_time = 200
let g:unite_source_file_mru_time_format = ''
let g:unite_enable_start_insert = 1
let g:unite_source_file_mru_ignore_pattern = mru_ignore
if !exists('g:unite_source_file_mru_limit')
  let g:unite_source_file_mru_limit = 1000
endif
" unite ウインドウの高さ
let g:unite_winheight = 10

call unite#set_substitute_pattern('', '[[:alnum:]]', '*\0', 100)
if has('win32')
  call unite#set_substitute_pattern('file', '[^~.]\zs/', '*/*', 20)
  call unite#set_substitute_pattern('file', '/\ze[^*]', '/*', 10)
else
  call unite#set_substitute_pattern('file', '[[:alnum:]]', '*\0', -150)
endif

function! s:unite_my_settings()
  NeoComplCacheDisableCaching
  NeoComplCacheLock
  " Overwrite settings.
  imap <buffer> jj <Plug>(unite_insert_leave)
  "imap <buffer> jj <Plug>(unite_exit)
  imap <buffer> <C-j> <Plug>(unite_exit)
  imap <buffer> <ESC> <Plug>(unite_exit)
	imap <buffer> <C-o> <Plug>(unite_insert_leave):<C-u>call unite#mappings#do_action('above')<CR>
  nmap <buffer> <C-n> <Plug>(unite_loop_cursor_down)
  nmap <buffer> <C-p> <Plug>(unite_loop_cursor_up)
  nmap <buffer> <C-j> <Plug>(unite_exit)
  "startinsert
endfunction
function! s:fuf_my_settings()
  inoremap <buffer> <C-j> <ESC>
endfunction

" howm
"
let QFixHowm_Key = '<Space>'
let QFixHowm_KeyB = ''
if !exists('howm_dir')
  let howm_dir = 'd:/document/howm'
endif
"let howm_fileencoding = 'utf-8'
"let howm_fileformat   = 'unix'
let g:QFix_PreviewEnable = 0
let g:QFix_Height = 5
"let g:QFix_Resize = 0
let g:QFix_HeightFixMode = 1
""""""""""""""""""""""""""""""""""
"             misc               "
""""""""""""""""""""""""""""""""""
" hatena.vim
let g:hatena_user = 'basyura'
let g:scratchBackupFile=$HOME . "/.scratch.txt"
"let g:hatena_edit_new_tab = 1
" vimwiki

if !exists('g:vimwiki_list')
  if has('mac')
    let g:vimwiki_list = [{'path':'~/dropbox/vimwiki/text/', 'path_html':'~/dropbox/vimwiki/html/'}]
  else
    let g:vimwiki_list = [{'path': "Z:/text", 'path_html/': "Z:/html/"}]
  endif
end
" taglist
let g:Tlist_GainFocus_On_ToggleOpen = 1
let g:Tlist_Show_One_File = 1
let Tlist_Close_On_Select = 1
" ubuntu の時だけ
if !has('mac') && !has('win32') && !has('win32unix')
	inoremap <silent> <esc> <esc>:call ForceImeOff()<cr>
	inoremap <silent> <C-[> <esc>:call ForceImeOff()<cr>
	inoremap <silent> <C-c> <esc>:call ForceImeOff()<cr>
	function! ForceImeOff()
		let imeoff = system('xvkbd -text "\[Control]\[Shift]\[space]" > /dev/null 2>&1')
	endfunction
endif
	
command! -nargs=? -complete=dir -bang CD  call s:ChangeCurrentDir('<args>', '<bang>') 
function! s:ChangeCurrentDir(directory, bang)
    if a:directory == ''
        lcd %:p:h
    else
        execute 'lcd' . a:directory
    endif

    if a:bang == ''
        pwd
    endif
endfunction

" for rails.vim
"nnoremap <silent> <Leader>r :<C-u>R<CR>


" Change current directory.
nnoremap <silent> <Space>cd :<C-u>CD<CR>

" twitvim
nnoremap <silent> <Space>po   :<C-u>WPosttoTwitter<Enter>
nnoremap <silent> s           :<C-u>WPosttoTwitter<Enter>
nnoremap <silent> <Space>fr   :<C-u>FriendsTwitter<Enter>
nnoremap <silent> <Space>re   :<C-u>RepliesTwitter<Enter>
nnoremap <silent> <Space>tt   :<C-u>ListTwitter tottoruby<Enter>
nnoremap <silent> <Space>nn   :<C-u>NextTwitter<Enter>
nnoremap <silent> <Space>pp   :<C-u>BackTwitter<Enter>
"nnoremap <Leader>u   yw:UserTwitter <C-R>+<CR>

if !exists('g:twitvim_browser_cmd')
  if has('mac')
    let g:twitvim_browser_cmd = "open -a firefox "
  else
    let g:twitvim_browser_cmd = "D:/Program\ Files/Mozilla\ Firefox/firefox.exe"
  endif
endif

"let twitvim_enable_python = 1



silent! nmap <Leader>q :QuickRun<CR>
let g:quickrun_config = {
      \ '*' : {'into' : 1},
      \}



nnoremap <Space>full :call FullScreen()<Enter>
function! FullScreen()
  set columns=195
  set lines=43
endfunction


" カーソル位置の highlight グループを取得する．
command! -nargs=0 GetHighlightingGroup echo 'hi<' . synIDattr(synID(line('.'),col('.'),1),'name') . '> trans<' . synIDattr(synID(line('.'),col('.'),0),'name') . '> lo<' . synIDattr(synIDtrans(synID(line('.'),col('.'),1)),'name') . '>'

" Load settings for each location.
augroup vimrc-local
  autocmd!
  "autocmd BufNewFile,BufReadPost,BufWinEnter * call s:vimrc_local(expand('<afile>:p:h'))
  autocmd BufNewFile,BufReadPost * call s:vimrc_local(expand('<afile>:p:h'))
augroup END

command! FindTags call s:vimrc_local(expand('<afile>:p:h'))
function! s:vimrc_local(loc)
"  let files = findfile('.vimrc.local', escape(a:loc, ' ') . ';', -1)
"  for i in reverse(filter(files, 'filereadable(v:val)'))
"    source `=i`
"  endfor
  let &l:tags=findfile('.tags' , '.;')
"  let &tags=findfile('.tags' , '.;')
endfunction

"http://vim-users.jp/2010/03/hack130/
command! -complete=file -nargs=+ VimGrep  call s:grep([<f-args>])
function! s:grep(args)
  execute 'vimgrep' '/'.a:args[-1].'/' join(a:args[:-2])
endfunction



"Command-line window

set cmdwinheight=10
"nnoremap <sid>(command-line-enter) q:
"xnoremap <sid>(command-line-enter) q:
"nnoremap <sid>(command-line-norange) q:<C-u>
"nmap :  <sid>(command-line-enter)
"xmap :  <sid>(command-line-enter)
"autocmd CmdwinEnter * :NeoComplCacheLock
function! s:init_cmdwin()
  nnoremap <buffer> q <C-c><CR>
  nnoremap <buffer> <C-j> <C-c><CR>
"  inoremap <buffer> q bw
"  inoremap <buffer> wq WQ
"
"  "cnoreabbrev q   'bd'
"  "inoreabbrev q   'bd'
"  "inoreabbrev q!  'bd!'
"  "inoreabbrev wq  'WQ'
"
  nnoremap <buffer> <Esc> :<C-u><C-c><C-h>
"  inoremap <buffer> <C-c> :<ESC>
  inoremap <buffer> <ESC> :<C-u><C-c><C-h>
  nnoremap <buffer> <TAB> :<C-u>quit<CR>
  inoremap <buffer><expr><CR>  pumvisible() ? "\<C-y>" : "\<CR>"
"  "inoremap <buffer><expr><C-h> pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
"  "inoremap <buffer><expr><BS>  pumvisible() ? "\<C-y>\<C-h>" : "\<C-h>"
"
"  " Completion.
"  "inoremap <buffer><expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
  inoremap <buffer><expr><TAB>  "\<C-n>"
"  " カーソル移動
"  inoremap <C-k> <Up>
"  inoremap <C-j> <Down>
"
"  startinsert!
endfunction
""autocmd CmdwinLeave * call s:leave_cmdwin()
""function! s:leave_cmdwin()
""  let g:neocomplcache_auto_completion_start_length = 2
""endfunction


function! Scouter(file, ...) 
  let pat = '^\s*$\|^\s*"'
  let lines = readfile(a:file)
  if !a:0 || !a:1
    let lines = split(substitute(join(lines, "\n"), '\n\s*\\', '', 'g'), "\n")
  endif
  return len(filter(lines,'v:val !~ pat'))
endfunction
command! -bar -bang -nargs=? -complete=file Scouter
\        echo Scouter(empty(<q-args>) ? $MYVIMRC : expand(<q-args>), <bang>0)
command! -bar -bang -nargs=? -complete=file GScouter
\        echo Scouter(empty(<q-args>) ? $MYGVIMRC : expand(<q-args>), <bang>0)

if has('mac')
  let g:restart_vim_progname = "MacVim"
end

" indent xml
command! IndentXML let @" = util#xml#indent(join(getline(1,'$'),"\n"))
" xpath
command! -nargs=1 XPath let @" = util#xml#xpath_text(join(getline(1,'$'),"\n") , <f-args>) | echo @"

command! MoveLeft call s:MoveLeft()
function! s:MoveLeft()
  winpos 0 0
  set lines=999
endfunction
function! s:scratch_my_settings()
  AlterCommand <buffer> q :Scratch<CR>
endfunction
" for twitvim
function! s:twitvim_my_settings()
  nnoremap <buffer> <Leader>u   yw:UserTwitter <C-R>+<CR>
  nnoremap <buffer> <C-j>   :bd!<CR>
endfunction
" for twitvim say
function! s:twitvim_say_my_settings()
  "NeoComplCacheLock
  NeoComplCacheCachingDictionary
  AlterCommand <buffer> q bd!<CR>
  nnoremap <buffer> <silent> <C-j> :bd!<CR>
endfunction
"
function! s:lingr_messages_setting()
  nmap <buffer> <silent> <Space>po <Plug>(lingr-messages-show-say-buffer)
endfunction

function! s:lingr_say_setting()
  nmap <buffer> <silent> <C-j> <Plug>(lingr-say-close)
endfunction

function! s:quickrun_setting()
  nmap <buffer> <C-j> :bd!<CR>
endfunction

function! s:qfix_howm_setting()
  nnoremap <silent> <buffer> <C-j> :bd<CR>
endfunction


"color for cygwin

if has('win32unix')
  hi Pmenu     ctermfg=white   ctermbg=black cterm=none
  hi PmenuSel  ctermfg=232     ctermbg=magenta
endif



" vim: foldmethod=marker
